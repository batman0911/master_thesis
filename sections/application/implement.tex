\subsection{Triển khai thuật toán}
\label{sec:implement}
Chương trình được chia làm ba giai đoạn \textit{Tiền xử lý}, \textit{Chương trình chính}, \textit{Đo đạc}.
\begin{itemize}
	\item \textit{Tiền xử lý}: trong giai đoạn này, các cấu hình trong các tập dữ liệu, được đọc vào và tính toán ma trận khoảng cách giữa các yêu cầu và lưu trữ vào các tệp. Các tệp có định dạng \code{json} và có schema như đối tượng \code{Instance} đã trình được trình bày trong mục \ref{sec:core-objects}. Các tệp này sẽ được đọc vào trong giai đoạn \textit{Chương trình chính} để giảm thiểu thời gian tính toán. Để đơn giản, phần tiền xử lý sử dụng ngôn ngữ lập trình \code{python}.
	\item \textit{Chương trình chính}: Đây là chương trình triển khai ALNS, được viết bằng ngôn ngữ \code{C++}. Các độ đo của chương trình được ghi ra các tệp logs để sử dụng cho giai đoạn \textit{đo đạc}.
	\item \textit{Đo đạc}: Trong giai đoạn này, các tệp logs được đọc vào và các độ đo được tính toán và phân tích.
\end{itemize}

Một trong những điểm mạnh của ALNS là triển khai được song song. Chúng ta có thể chạy nhiều luồng cùng một lúc để tăng tốc độ tính toán. Điều này đặc biệt hữu ích khi cấu hình cần giải có nhiều yêu cầu. Khi tìm kiếm nghiệm trong lân cận của nghiệm hiện tại, ta khởi tạo nhiều luồng cùng tìm kiếm. Điều này không những tăng tốc chương trình mà còn giúp cho thuật toán khó bị bẫy trong nghiệm tối ưu cục bộ hơn khi triển khai đơn luồng do sự đa dạng của việc tìm kiếm (bằng nhiều luồng). Ngoài ra có những cách triển khai đa luồng khác. Ví dụ, trong thuật toán "hủy" và "sửa", ta hoàn toàn có thể bỏ đi các yêu cầu hoặc thêm lại các yêu cầu một cách song song từ các tuyến đường khác nhau.

Trong thực tế, tác giả chọn cách triển khai đầu tiên vì đơn giản và dễ hiểu. Chúng ta chỉ cần khởi tạo các luồng một lần mà không cần phải cấp lại tài nguyên. Với cách làm thứ hai, ta liên tục phải tạo các luồng mới và cấp lại tài nguyên cho chúng, điều này có thể làm giảm hiệu năng của chương trình vì thực tế thì việc khởi tạo luồng là đắt đỏ. Tác giả cũng thử nghiệm cách làm thứ hai với thư viện \code{OpenMP} (là một thư viện hỗ trợ lập trình bất đồng bộ và song song nổi tiếng dành cho \code{C++}) tuy nhiên hiệu năng không đạt tốt như cách triển khai đa luồng đầu tiên.